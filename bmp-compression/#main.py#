from tkinter import *
from tkinter import filedialog
from math import ceil, cos, pi

def bytesToInt(bytes, byteorder='little', signed=False):
    """ Convert bytes to integer"""
    return int.from_bytes(bytes, byteorder=byteorder, signed=signed)

def myround(value, lowerbound, higherbound):
    """ Round value back to the interval between [lowerbound, higherbound]"""
    if value < lowerbound:
        return lowerbound
    if value > higherbound:
        return higherbound
    return value

def matrixMult(a, b):
	a_h = len(a)
	a_w = len(a[0])
	b_h = len(b)
	b_w = len(b[0])
	if a_w != b_h:
		raise Exception("Width of a must be equal to height of b")
	c = [[0 for i in range(a_h)] for i in range(b_w)]
	for i in range(a_h):
		for j in range(b_w):
			for k in range(a_w):
				c[i][j] += a[i][k]*b[k][j]
	return c			
def transpose(a):
	h = len(a)
	w = len(a[0])
	res = [[0 for i in range(w)] for i in range(h)]
	for i in range(h):
		for j in range(w):
			res[j][i] = a[i][j]
class Bmp24BitImage():
    def __init__(self, path):
        if (not path.endswith('.bmp')):
            raise Exception("File must be bmp")
        self.img = self.__readImg(path)
        self.fileSize = bytesToInt(self.img[2:6])
        self.width = bytesToInt(self.img[18:22], signed=True)
        self.height = bytesToInt(self.img[22:26], signed=True)
        self.bitsPerPixel = bytesToInt(self.img[28:30])
        self.dataOffset = bytesToInt(self.img[10:14])
        self.imgSize = bytesToInt(self.img[34:38])
        self.bytesPerPixel = self.bitsPerPixel // 8
        self.bytesPerRow = ceil((self.width * self.bytesPerPixel) / 4) * 4
        self.extraBytesPerRow = self.bytesPerRow - (self.width * self.bytesPerPixel)
        
    def original(self):
        pixels = []
        i = self.dataOffset
        while i < len(self.img):
            rowPixels = []
            for k in range(i, i + self.width * self.bytesPerPixel, self.bytesPerPixel):
                b = self.img[k]
                g = self.img[k+1]
                r = self.img[k+2]
                rowPixels.append((r,g,b))
            i += self.bytesPerRow
            pixels.append(rowPixels)
        return pixels
               
    def __readImg(self, path):
        img = bytearray()
        with open(path, "rb") as f:
            byte = f.read(1)
            while byte:
                img += byte
                byte = f.read(1)
        return img

class Compressor:
	def __init__(self, bmpImg):
		self.bmpImg = bmpImg
		self.imgPixels = bmpImg.original().reverse()
		self.quantize_table = [[1,1,2,4,8,16,
                                        [],[],[],[],[],[],[]]
		self.block = 8

	def compress(self):
		y, cb, cr = self.rgb2ycbcr()
		y = self.addPadding(y, self.block)
		cb = self.addPadding(cb, self.block)
		cr = self.addPadding(cr, self.block)
		#self.downSampling()
		dct = self.dct(self.block)
		transformed_y = self.transform(y, dct)
		transformed_cb = self.transform(cb, dct)
		transformed_cr = self.transform(cr, dct)

		quantized_y = self.quantize(transformed_y)
		quantized_cb = self.quantize(transformed_cb)
		quantized_cr = self.quantize(transformed_cr)
		pass

	def quantize(self, x):
		pass

	def addPadding(self, x, size):
		h = len(x)
		w = len(x[0])
		if h % size != 0 :
			new_h = ceil(h / size) * size
			for i in range(new_h - h):
				x.append([255 for i in range(old_w)])
			h = new_h
		if w % size != 0:
			new_w = ceil(w / size) * size
			for i in range(h):
				x[i] = x[i] + [255 for j in range(new_w - w)]
			w = new_w
		return x


	def transform(self, x, dct):
		blockSize = len(dct)
		h = len(x)
		w = len(x[0])
		for i in range(0, h, blockSize):
			for j in range(0, w, blockSize):
				block = [x[k][j:(j+blockSize)] for k in range(k, i + blockSize)]
				transformed_block = matrixMult(matrixMult(dct, block), transpose(dct))

				for k in range(i, i + blockSize):
					for g in range(j, j + blockSize):
						x[k][g] = transformed_block[k-i][g-j]




	def dct(self, N):
		C = [[0 for i in range(N)] for i in range(N)]
		for i in range(N):
			for j in range(N):
				a = (1 / N) ** 0.5
				if i != 0:
					a = (2/N) ** 0.5
				C[i][j] = a * cos(((2*j+1)*i*pi) / (2*N))
		return C

	def rgb2ycbcr(self):
		"""
			Y = 0.299 R + 0.587 G + 0.114 B
			Cb = - 0.1687 R - 0.3313 G + 0.5 B + 128
			Cr = 0.5 R - 0.4187 G - 0.0813 B + 128
		"""
		Y = []
		Cb = []
		Cr = []
		for row in self.imgPixels:
			y_row = []
			cb_row = []
			cr_row = []
			for (r,g,b) in row:
				y_row.append(0.299*r + 0.587*g + 0.114*b)
				cb_row.append(-0.1687*r-0.3313*g+0.5*b+128)
				cr_row.append(0.5*r-0.4187*g-0.0813*b+128)
			Y.append(y_row)
			Cb.append(cb_row)
			Cr.append(cr_row)
		return Y, Cb, Cr






if __name__ == "__main__":
    # Init root
    root = Tk()
    root.title("Q3")
    root.geometry("1000x700")
    # Init global variables
    original = grayscale = dark = vividP = [] # array of pixel color: [(r,g,b)]
    CANVAS_WIDTH = 900
    CANVAS_HEIGHT = 700

    def onExit():
        root.quit()
        
    def drawPixels(pixels):
        global cv, cvImg
        global CANVAS_WIDTH, CANVAS_HEIGHT
        cv.delete(ALL) # Clean up canvas
        # Reset image
        cvImg = PhotoImage(width=CANVAS_WIDTH,height=CANVAS_HEIGHT)
        cv.create_image((CANVAS_WIDTH//2, CANVAS_HEIGHT//2), image=cvImg, state="normal")
        h = len(pixels) # image height
        w = len(pixels[0]) # image width
        colAlign = CANVAS_WIDTH // 2 - w // 2 # Align image to be center
        # Draw each pixel 
        for row in range(h):
            for col in range(w):
                color = "#%02x%02x%02x" % pixels[row][col] # Convert (r,g,b) to hexa
                xx, yy = colAlign+col, row
                cvImg.put(color, (xx,yy))

    def imgSelect():
        global label, cv, cvImg
        global original, grayscale, dark, vivid
        # Open dialog to choose file
        root.filename = filedialog.askopenfilename(initialdir=".",title="Select an image",filetypes=(("bmp files", "*.bmp"),))
        if root.filename:
            # Process image byte by byte
            rawImg = Bmp24BitImage(root.filename)
            original = rawImg.original()


            # Draw original image
            #drawPixels(original)
            
    
    # Buttons
    fileBtn = Button(root, text="Select BMP image", command=imgSelect)


    # Display buttons
    fileBtn.pack()

    # Canvas to draw image byte by byte
    cv = Canvas(root, width=CANVAS_WIDTH, height=CANVAS_HEIGHT)
    cv.pack()
    
    root.protocol("WM_DELETE_WINDOW", onExit)
    root.mainloop()